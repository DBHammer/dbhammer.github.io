<!DOCTYPE html>
<html lang="en" data-dark="false">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <!--
  put your analytics (e.g. Google Analytics) tracking code here
-->

  <!--
  put your search engine verification (e.g. Google Search Console) tag here
-->

  






























<meta name="viewport" content="width=device-width, initial-scale=1">

<title>OceanBase性能调优 | DBHammer</title>

<link rel="icon" href="">

<meta name="title" content="OceanBase性能调优">
<meta name="description" content="DaSE, ECNU. The official website of DBHammer, DaSE, ECNU.">

<meta property="og:title" content="OceanBase性能调优">
<meta property="og:site_title" content="DBHammer">
<meta property="og:description" content="DaSE, ECNU. The official website of DBHammer, DaSE, ECNU.">
<meta property="og:url" content="https://dbhammer.github.io">
<meta property="og:image" content="">
<meta property="og:locale" content="en_US">

<meta property="twitter:title" content="OceanBase性能调优">
<meta property="twitter:description" content="DaSE, ECNU. The official website of DBHammer, DaSE, ECNU.">
<meta property="twitter:url" content="https://dbhammer.github.io">
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:image" content="">


  <meta name="author" content="张惠东">
  <meta property="og:type" content="article">
  <meta property="og:updated_time" content="2025-07-09T09:33:03+00:00">
  <meta property="article:published_time" content="2022-05-26T00:00:00+00:00">
  <meta property="article:modified_time" content="2025-07-09T09:33:03+00:00">
  <meta name="revised" content="2025-07-09T09:33:03+00:00">


<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "BlogPosting",
      "author": { "@type": "Person", "name": "OceanBase性能调优" },
      "datePublished": "2022-05-26T00:00:00+00:00",
      "dateModified": "2025-07-09T09:33:03+00:00",
    
    "name": "OceanBase性能调优",
    "description": "DaSE, ECNU. The official website of DBHammer, DaSE, ECNU.",
    "headline": "OceanBase性能调优",
    "publisher": {
      "@type": "Organization",
      "logo": { "@type": "ImageObject", "url": "" }
    },
    "url": "https://dbhammer.github.io"
  }
</script>

<link rel="alternate" type="application/rss+xml" href="https://dbhammer.github.io/feed.xml">

  <!-- Google Fonts -->
<!-- automatically get url from fonts used in theme file -->

<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?display=swap&&family=Barlow:ital,wght@0,200;0,400;0,500;0,600;1,200;1,400;1,500;1,600&amp;family=Roboto+Mono:ital,wght@0,200;0,400;0,500;0,600;1,200;1,400;1,500;1,600" rel="stylesheet">

<!-- Font Awesome icons (load asynchronously due to size) -->

<link href="https://use.fontawesome.com/releases/v6.7.0/css/all.css" rel="stylesheet" media="none" onload="this.removeAttribute('media'); this.onload = null;">
<noscript>
  <link href="https://use.fontawesome.com/releases/v6.7.0/css/all.css" rel="stylesheet">
</noscript>

  <!-- third party styles -->
<!-- https://stylishthemes.github.io/Syntax-Themes/pygments/ -->
<link href="https://cdn.jsdelivr.net/gh/StylishThemes/Syntax-Themes/pygments/css-github/pygments-tomorrow-night-eighties.css" rel="stylesheet">

<!-- include all sass in styles folder -->


  
    <link href="/_styles/-theme.css" rel="stylesheet">
  

  
    <link href="/_styles/alert.css" rel="stylesheet">
  

  
    <link href="/_styles/all.css" rel="stylesheet">
  

  
    <link href="/_styles/anchor.css" rel="stylesheet">
  

  
    <link href="/_styles/background.css" rel="stylesheet">
  

  
    <link href="/_styles/banner.css" rel="stylesheet">
  

  
    <link href="/_styles/blog-article.css" rel="stylesheet">
  

  
    <link href="/_styles/body.css" rel="stylesheet">
  

  
    <link href="/_styles/bold.css" rel="stylesheet">
  

  
    <link href="/_styles/button.css" rel="stylesheet">
  

  
    <link href="/_styles/card.css" rel="stylesheet">
  

  
    <link href="/_styles/checkbox.css" rel="stylesheet">
  

  
    <link href="/_styles/citation.css" rel="stylesheet">
  

  
    <link href="/_styles/code.css" rel="stylesheet">
  

  
    <link href="/_styles/cols.css" rel="stylesheet">
  

  
    <link href="/_styles/dark-toggle.css" rel="stylesheet">
  

  
    <link href="/_styles/details.css" rel="stylesheet">
  

  
    <link href="/_styles/feature.css" rel="stylesheet">
  

  
    <link href="/_styles/figure.css" rel="stylesheet">
  

  
    <link href="/_styles/float.css" rel="stylesheet">
  

  
    <link href="/_styles/font.css" rel="stylesheet">
  

  
    <link href="/_styles/footer.css" rel="stylesheet">
  

  
    <link href="/_styles/form.css" rel="stylesheet">
  

  
    <link href="/_styles/gallery.css" rel="stylesheet">
  

  
    <link href="/_styles/grid.css" rel="stylesheet">
  

  
    <link href="/_styles/header.css" rel="stylesheet">
  

  
    <link href="/_styles/heading.css" rel="stylesheet">
  

  
    <link href="/_styles/highlight.css" rel="stylesheet">
  

  
    <link href="/_styles/icon.css" rel="stylesheet">
  

  
    <link href="/_styles/image.css" rel="stylesheet">
  

  
    <link href="/_styles/input.css" rel="stylesheet">
  

  
    <link href="/_styles/link.css" rel="stylesheet">
  

  
    <link href="/_styles/list.css" rel="stylesheet">
  

  
    <link href="/_styles/main.css" rel="stylesheet">
  

  
    <link href="/_styles/member-intro.css" rel="stylesheet">
  

  
    <link href="/_styles/paragraph.css" rel="stylesheet">
  

  
    <link href="/_styles/portrait.css" rel="stylesheet">
  

  
    <link href="/_styles/post-excerpt.css" rel="stylesheet">
  

  
    <link href="/_styles/post-info.css" rel="stylesheet">
  

  
    <link href="/_styles/post-nav.css" rel="stylesheet">
  

  
    <link href="/_styles/quote.css" rel="stylesheet">
  

  
    <link href="/_styles/role.css" rel="stylesheet">
  

  
    <link href="/_styles/rule.css" rel="stylesheet">
  

  
    <link href="/_styles/search-box.css" rel="stylesheet">
  

  
    <link href="/_styles/search-info.css" rel="stylesheet">
  

  
    <link href="/_styles/section.css" rel="stylesheet">
  

  
    <link href="/_styles/table.css" rel="stylesheet">
  

  
    <link href="/_styles/tags.css" rel="stylesheet">
  

  
    <link href="/_styles/textbox.css" rel="stylesheet">
  

  
    <link href="/_styles/tooltip.css" rel="stylesheet">
  

  
    <link href="/_styles/two-col.css" rel="stylesheet">
  

  
    <link href="/_styles/util.css" rel="stylesheet">
  


<!-- include all css in styles folder -->



  <!-- third party scripts -->
<script src="https://unpkg.com/@popperjs/core@2" defer></script>
<script src="https://unpkg.com/tippy.js@6" defer></script>
<script src="https://unpkg.com/mark.js@8" defer></script>

<!-- include all js in scripts folder -->


  <script src="/_scripts/anchors.js"></script>

  <script src="/_scripts/dark-mode.js"></script>

  <script src="/_scripts/fetch-tags.js"></script>

  <script src="/_scripts/search.js"></script>

  <script src="/_scripts/site-search.js"></script>

  <script src="/_scripts/table-wrap.js"></script>

  <script src="/_scripts/tooltip.js"></script>

  <script src="/_scripts/tooltips.js"></script>

  <script src="/_scripts/true-hide.js"></script>

  <script src="/_scripts/util.js"></script>


</head>

  <body>
    







<header class="background" style="--image: url('')" data-dark="true">
  <a href="/" class="home">
    
      <span class="logo">
        
          <svg xmlns="http://www.w3.org/2000/svg" viewbox="-50 -50 100 100" style="overflow: visible">
  <style>
  circle {
    animation: float 2s ease-out forwards infinite,
    fade 2s ease-out forwards infinite;
  }
  circle:nth-of-type(1) {
    animation-delay: 0.1s;
  }
  circle:nth-of-type(2) {
    animation-delay: 0.4s;
  }
  circle:nth-of-type(3) {
    animation-delay: 1.1s;
  }
  @keyframes float {
    50% {
      transform: translateY(0);
    }
    100% {
      transform: translateY(-45px);
    }
  }
  @keyframes fade {
    75% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }
  </style>
  <circle fill="#b3e5fc" cx="0" cy="0" r="3"></circle>
  <circle fill="#b3e5fc" cx="0" cy="0" r="3"></circle>
  <circle fill="#b3e5fc" cx="0" cy="0" r="3"></circle>
  <path fill="#81d4fa" d="
      M 0.0 -15.0
      L -21.7 -2.5
      L -21.7 22.5
      L -0.0 35.0
      L 21.7 22.5
      L 21.7 -2.5
      z
    "></path>
  <path fill="#b3e5fc" d="
      M 0.0 -15.0
      L -21.7 -2.5
      L 0 10
      L 21.7 -2.5
      z
    "></path>
  <path fill="none" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round" d="
      M -15 -43
      L -10 -43
      L -10 -19.2
      L -30.3 -7.5
      L -30.3 27.5
      L -0 45
      L 30.3 27.5
      L 30.3 -7.5
      L 10 -19.2
      L 10 -43
      L 15 -43
    "></path>
</svg>

        
      </span>
    
    
      <span class="title-text" data-tooltip="Home">
        
          <span class="title">DBHammer</span>
        
        
          <span class="subtitle">DaSE, ECNU</span>
        
      </span>
    
  </a>

  <input class="nav-toggle" type="checkbox" aria-label="show/hide nav">

  <nav>
    
    
      
        <a href="/project/" data-tooltip="Software, datasets, and more">
          项目
        </a>
      
    
      
        <a href="/blog/" data-tooltip="Musings and miscellany">
          博客
        </a>
      
    
      
        <a href="/research/" data-tooltip="Published works">
          论文
        </a>
      
    
      
        <a href="/work/" data-tooltip="News">
          新闻
        </a>
      
    
      
        <a href="/news/" data-tooltip="News">
          新闻
        </a>
      
    
      
        <a href="/team/" data-tooltip="About our team">
          成员
        </a>
      
    
      
        <a href="/contact/" data-tooltip="Email, address, and location">
          就业去向
        </a>
      
    
  </nav>
</header>

    <main>
      <!--
  modify main content of page:
  - add section breaks
  - attach section properties
  - filter out blank sections
-->






  
  
  

  <section class="background" data-size="1">
    <!--
  background: ;
  dark: ;
  size: 1;
-->


<h1 class="center">OceanBase性能调优</h1>

<div class="post-info">
  
    
    
      



<div class="portrait-wrapper">
  <a href="/members/%E5%BC%A0%E6%83%A0%E4%B8%9C.html" class="portrait" data-style="tiny" aria-label="张惠东">
    
      <i class="icon fas fa-user-graduate"></i>
    

    <img src="/photos/zhanghuidong.jpg" class="portrait-image" alt="member portrait" loading="lazy" onerror="this.src = '/images/fallback.svg'; this.onerror = null;">

    
      <span class="portrait-name">
        张惠东
      </span>
    

    
      <span class="portrait-description">
        
      </span>
    

    
  </a>
</div>

    
  

  
  

  
    <span data-tooltip="Originally published on">
      <i class="icon fa-regular fa-calendar"></i>
      <span>May 26, 2022</span>
    </span>
  

  
    <span data-tooltip="Last updated on">
      <i class="icon fa-solid fa-clock-rotate-left"></i>
      <span>July 09, 2025</span>
    </span>
  
</div>


  


  <div class="tags" data-link="/blog">
    
      <a href='blog?search="tag:%20oceanbase"' class="tag" data-tooltip='Show items with the tag "oceanbase"'>
        oceanbase
      </a>
    
  </div>
  </section>

  
  
  

  <section class="background" data-size="page">
    <!--
  background: ;
  dark: ;
  size: ;
-->


<p>本文介绍调试OceanBase代码的方法，以及Nested-Loop-Join性能优化的思路</p>

<h2 id="编译部署oceanbase">编译部署OceanBase</h2>

<ul>
  <li>
    <p>从源代码编译OceanBase</p>

    <p>想要在OceanBase源代码上进行调试，优化，第一件要做的事就是从源代码编译OceanBase。这里推荐克隆<a href="https://github.com/oceanbase/oceanbase/tree/oceanbase_competition">OceanBase数据库大赛的比赛分支</a>，克隆完成之后按照<a href="https://open.oceanbase.com/docs/community/oceanbase-database/V3.1.0/get-the-oceanbase-database-by-using-source-code">官方教程</a>从源码构建OceanBase数据库，其中debug版本可以打断点调试，release版本可以用来测试性能。</p>
  </li>
  <li>
    <p>安装Oceanbase部署工具OBD</p>

    <p>接下来参照<a href="https://open.oceanbase.com/docs/community/oceanbase-database/V3.1.0/use-obd-to-obtain-the-oceanbase-database">官方文档</a>安装OceanBase的部署工具OBD，安装完成之后进入OceanBase源码的编译目录（如build_release），在ocenbase-ce v3.1.0的基础上创建tag为obcompetition的OBD镜像。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  obd mirror create <span class="nt">-n</span> oceanbase-ce <span class="nt">-V</span> 3.1.0 <span class="nt">-p</span> ./usr/local <span class="nt">-t</span> obcompetition
</code></pre></div>    </div>
  </li>
  <li>
    <p>部署数据库</p>

    <p>创建完镜像之后，可以通过配置文件部署数据库，官方有一些配置文件的<a href="https://github.com/oceanbase/obdeploy/tree/master/example">示例</a>，本文使用的配置文件ob.yaml如下：</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  oceanbase-ce:
    <span class="c"># tag设置为刚才创建镜像obcompetition的tag</span>
  	tag: obcompetition
    servers:
    - name: <span class="nb">test
      </span>ip: 127.0.0.1
    
    global:
  		<span class="c"># home_path需要修改成自己想要部署的目录</span>
      home_path: <span class="k">*****</span>
      devname: lo
      mysql_port: 2881
      rpc_port: 2882
      zone: zone1
      cluster_id: 1
      datafile_size: 10G
      appname: obcompetition
    
    <span class="nb">test</span>:
      syslog_level: INFO
      enable_syslog_recycle: <span class="nb">true
      </span>enable_syslog_wf: <span class="nb">true
      </span>max_syslog_file_count: 4
      memory_limit: 12G
      system_memory: 6G
      cpu_count: 16
</code></pre></div>    </div>

    <p>部署数据库前确定目录home_path为空，之后使用autodeploy自动部署名称为obcompetition的数据库。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  obd cluster deploy obcompetition <span class="nt">-c</span> ob.yaml
</code></pre></div>    </div>

    <p>启动数据库，创建测试用租户test，并且将除sys租户以外的资源全部给test租户。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  obd cluster start obcompetition
  obd cluster tenant create obcompetition <span class="nt">--tenant-name</span> <span class="nb">test</span>
</code></pre></div>    </div>

    <p>创建完租户之后就可以通过mysql客户端，连接OceanBase的test租户或者sys租户。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  mysql <span class="nt">--host</span> 127.0.0.1 <span class="nt">--port</span> 2881 <span class="nt">-uroot</span>@test
  mysql <span class="nt">--host</span> 127.0.0.1 <span class="nt">--port</span> 2881 <span class="nt">-uroot</span>@sys
</code></pre></div>    </div>
  </li>
  <li>
    <p>修改代码后重新部署数据库</p>

    <p>在源代码上进行修改之后，首先需要重新编译代码，然后用编译完的内容替换正在运行的observer。首先查看正在运行的observer所在位置，即bin/observer所在的位置，然后ls -l看出这个observer是一个软连接，想要替换它只需要将软连接连接到刚编译出来的observer二进制文件。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  ps <span class="nt">-ef</span> | <span class="nb">grep </span>observer
  <span class="nb">ls</span> <span class="nt">-l</span> <span class="k">***</span>/bin/observer
</code></pre></div>    </div>

    <p>最后重新启动obcompetition</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  obd cluster restart obcompetition
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="代码调试工具">代码调试工具</h2>

<hr>

<ul>
  <li>
    <p>vscode远程调试</p>

    <p>在阅读，修改OceanBase源码的时候，需要调试代码，不过OceanBase需要的配置比较高，一般部署在服务器上，这时候使用vscode进行远程调试就比较优雅。</p>

    <p>首先在vscode装一下Remote - SSH插件，打开服务器上的OceanBase源代码目录，然后再Debug界面创建一个新的launch.json文件。</p>

    <p><img src="/auto-image/picrepo/4d564b4d-4dfe-44bf-869b-9b0c6dddf45a.png" alt="创建新的launch.json"></p>

    <p>创建新的launch.json</p>

    <p>将launch.json替换为下面的配置，”configurations”→”program”需要替换为OceanBase配置文件里对应内容。</p>

    <div class="language-json highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="p">{</span><span class="w">
      </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="p">{</span><span class="w">
              </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"(gdb) Attach"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"attach"</span><span class="p">,</span><span class="w">
  						</span><span class="err">//</span><span class="w"> </span><span class="err">program需要替换为/home_path/bin/observer</span><span class="w">
  						</span><span class="err">//</span><span class="w"> </span><span class="err">其中home_path是OceanBase配置文件里的对应内容</span><span class="w">
              </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"****"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"processId"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${input:FindPID}"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"sudo"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
              </span><span class="nl">"miDebuggerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                  </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">}</span><span class="w">
              </span><span class="p">],</span><span class="w">
  						</span><span class="err">//</span><span class="w"> </span><span class="err">这里建立了一些目录映射</span><span class="w">
  						</span><span class="err">//</span><span class="w"> </span><span class="err">如果调试的时候提示找不到source，还需要自己加上对应的目录映射</span><span class="w">
              </span><span class="nl">"sourceFileMap"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                  </span><span class="nl">"./build_debug/src/observer/./src/observer/omt"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/observer/omt"</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/sql/parser/./src/sql/parser"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/sql/parser"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/sql/./src/sql"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/sql"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/sql/engine/join/./src/sql/engine/join"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/sql/engine/join"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/storage/./src/storage"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/storage"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/rootserver/./src/rootserver"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/rootserver"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">},</span><span class="w">
                  </span><span class="nl">"./build_debug/src/share/./src/share"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                      </span><span class="nl">"editorPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/src/share"</span><span class="p">,</span><span class="w">
                      </span><span class="nl">"useForBreakpoints"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                  </span><span class="p">}</span><span class="w">
              </span><span class="p">}</span><span class="w">
          </span><span class="p">}</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"inputs"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="p">{</span><span class="w">
              </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"FindPID"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"command"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shellCommand.execute"</span><span class="p">,</span><span class="w">
              </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                  </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ps -aux | grep /bin/observer | awk '{print $2}' | head -1"</span><span class="p">,</span><span class="w">
                  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Select your observer PID"</span><span class="p">,</span><span class="w">
                  </span><span class="nl">"useFirstResult"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
              </span><span class="p">}</span><span class="w">
          </span><span class="p">}</span><span class="w">
      </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>

    <p>然后在服务器上装一个Tasks Shell Input插件，来通过脚本动态获取observer的进程id。</p>

    <p><img src="/auto-image/picrepo/7452acdd-b1e5-46da-b020-6c23b1ac1f16.png" alt="安装Tasks Shell Input插件"></p>

    <p>安装Tasks Shell Input插件</p>

    <p>这样子在启动observer以后就能成功gdb attach了。</p>

    <p><img src="/auto-image/picrepo/95f5bac3-abc6-4c7c-8340-b5a866b80b2b.png" alt="成功gdb attach"></p>

    <p>成功gdb attach</p>
  </li>
  <li>
    <p>打日志调试</p>

    <p>vscode调试还是存在一些问题的，比如打断点的位置可能有很多系统进程都会访问（尤其是存储层的代码），mysql客户端输入sql以后，catch住的进程不一定是执行sql的工作线程，函数的调用栈可能不是你想要的，这时候可以通过打日志的方式进行调试。</p>

    <p>OceanBase的日志类型定义在deps/oblib/src/lib/oblog/ob_log_module.h里面，日志目录在/home_path/log，日志内容的格式：</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="o">[</span><span class="nb">time</span><span class="o">]</span>log_level[module_name]function_name<span class="o">(</span>filename:file_no<span class="o">)[</span>thread_id]
  <span class="o">[</span>Ytrace_id0_trace_id1][log<span class="o">=</span>last_log_print_time]log_data
    
  <span class="c">#time 日志记录时间</span>
  <span class="c">#log_level 日志级别</span>
  <span class="c">#module_name 模块名</span>
  <span class="c">#filename:file_no 文件名:行号</span>
  <span class="c">#thread_id 线程id</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>此外，官方也有讲<a href="https://github.com/oceanbase/oceanbase/wiki/how_to_debug">一些调试手段</a>。</p>

<h2 id="性能测试工具sysbench">性能测试工具SysBench</h2>

<hr>

<p>OceanBase数据库大赛使用SysBench进行性能测试，首先在测试机（客户端）上<a href="https://github.com/akopytov/sysbench">安装sysbench</a>。</p>

<ul>
  <li>
    <p>subplan.lua</p>

    <p>性能测试使用的是sysbench的subplan.lua脚本，该脚本在sysbench安装目录内，脚本里的schema为两张表t1和t2。</p>

    <div class="language-sql highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span><span class="p">(</span>
  	<span class="n">c1</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span> 
  	<span class="n">c2</span> <span class="nb">int</span><span class="p">,</span> 
  	<span class="n">c3</span> <span class="nb">int</span><span class="p">,</span> 
  	<span class="n">v1</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v2</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v3</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v4</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v5</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v6</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v7</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v8</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v9</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
  <span class="p">);</span>
    
  <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t2</span><span class="p">(</span>
  	<span class="n">c1</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span> 
  	<span class="n">c2</span> <span class="nb">int</span><span class="p">,</span> 
  	<span class="n">c3</span> <span class="nb">int</span><span class="p">,</span> 
  	<span class="n">v1</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v2</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v3</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v4</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v5</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v6</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v7</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v8</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> 
  	<span class="n">v9</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
  <span class="p">)</span>
</code></pre></div>    </div>

    <p>t1，t2表建完后插入数据。</p>

    <div class="language-sql highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v5</span><span class="p">,</span> <span class="n">v6</span><span class="p">,</span> <span class="n">v7</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v9</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(...);</span>
  <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t2</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v5</span><span class="p">,</span> <span class="n">v6</span><span class="p">,</span> <span class="n">v7</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v9</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(...);</span>
</code></pre></div>    </div>

    <p>插入数据后在t2表建索引，由于两个索引键都非主键，这两个索引都是二级索引，在查内表时会有一个回表操作，也就是根据索引键查询主键对应的行数据。</p>

    <div class="language-sql highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">create</span> <span class="k">index</span> <span class="n">t2_i1</span> <span class="k">on</span> <span class="n">t2</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="k">local</span><span class="p">;</span>
  <span class="k">create</span> <span class="k">index</span> <span class="n">t2_i2</span> <span class="k">on</span> <span class="n">t2</span><span class="p">(</span><span class="n">c3</span><span class="p">)</span> <span class="k">local</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Select操作限定外表为200个元素的范围查询，通过Hint强制使用Nested-Loop-Join（Index Nested-Loop-Join），并且在c2，c3列进行等值连接。</p>

    <div class="language-sql highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">select</span> <span class="cm">/*+ordered use_nl(A,B)*/</span> <span class="o">*</span> 
  <span class="k">from</span> <span class="n">t1</span> <span class="n">A</span><span class="p">,</span> <span class="n">t2</span> <span class="n">B</span> 
  <span class="k">where</span> <span class="n">A</span><span class="p">.</span><span class="n">c1</span> <span class="o">&gt;=</span> <span class="o">?</span> <span class="k">and</span> <span class="n">A</span><span class="p">.</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="o">?</span> <span class="k">and</span> <span class="n">A</span><span class="p">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">c2</span> <span class="k">and</span> <span class="n">A</span><span class="p">.</span><span class="n">c3</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">c3</span>
</code></pre></div>    </div>

    <p>explain看一下OceanBase的查询执行计划，A表是一个全表的scan，查出200行数据作为内表，在一次查询内，对于内表的每一行数据，B表作为外表可以通过t2_i2索引快速定位到相对应的匹配的数据。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="o">===============================================</span>
  |ID|OPERATOR        |NAME    |EST. ROWS|COST  |
  <span class="nt">-----------------------------------------------</span>
  |0 |NESTED-LOOP JOIN|        |193      |138185|
  |1 | TABLE SCAN     |A       |200      |188   |
  |2 | TABLE SCAN     |B<span class="o">(</span>t2_i2<span class="o">)</span>|1        |690   |
  <span class="o">===============================================</span>
    
  Outputs &amp; filters: 
  <span class="nt">-------------------------------------</span>
  0 - output<span class="o">([</span>A.c1], <span class="o">[</span>A.c2], <span class="o">[</span>A.c3], <span class="o">[</span>A.v1], <span class="o">[</span>A.v2], <span class="o">[</span>A.v3], <span class="o">[</span>A.v4], <span class="o">[</span>A.v5], <span class="o">[</span>A.v6], <span class="o">[</span>A.v7], <span class="o">[</span>A.v8], <span class="o">[</span>A.v9], <span class="o">[</span>B.c1], <span class="o">[</span>B.c2], <span class="o">[</span>B.c3], <span class="o">[</span>B.v1], <span class="o">[</span>B.v2], 
  		<span class="o">[</span>B.v3], <span class="o">[</span>B.v4], <span class="o">[</span>B.v5], <span class="o">[</span>B.v6], <span class="o">[</span>B.v7], <span class="o">[</span>B.v8], <span class="o">[</span>B.v9]<span class="o">)</span>, filter<span class="o">(</span>nil<span class="o">)</span>,
      conds<span class="o">(</span>nil<span class="o">)</span>, nl_params_<span class="o">([</span>A.c2], <span class="o">[</span>A.c3]<span class="o">)</span>, <span class="nv">batch_join</span><span class="o">=</span><span class="nb">false
    
  </span>1 - output<span class="o">([</span>A.c1], <span class="o">[</span>A.c2], <span class="o">[</span>A.c3], <span class="o">[</span>A.v1], <span class="o">[</span>A.v2], <span class="o">[</span>A.v3], <span class="o">[</span>A.v4], <span class="o">[</span>A.v5], <span class="o">[</span>A.v6], <span class="o">[</span>A.v7], <span class="o">[</span>A.v8], <span class="o">[</span>A.v9]<span class="o">)</span>, filter<span class="o">(</span>nil<span class="o">)</span>,
  	  access<span class="o">([</span>A.c1], <span class="o">[</span>A.c2], <span class="o">[</span>A.c3], <span class="o">[</span>A.v1], <span class="o">[</span>A.v2], <span class="o">[</span>A.v3], <span class="o">[</span>A.v4], <span class="o">[</span>A.v5], <span class="o">[</span>A.v6], <span class="o">[</span>A.v7], <span class="o">[</span>A.v8], <span class="o">[</span>A.v9]<span class="o">)</span>, partitions<span class="o">(</span>p0<span class="o">)</span>,
  	  <span class="nv">is_index_back</span><span class="o">=</span><span class="nb">false</span>,
  	  range_key<span class="o">([</span>A.c1]<span class="o">)</span>, range[200 <span class="p">;</span> 400<span class="o">)</span>,
  	  range_cond<span class="o">([</span>A.c1 <span class="o">&gt;=</span> 200], <span class="o">[</span>A.c1 &lt; 400]<span class="o">)</span>
    
  2 - output<span class="o">([</span>B.c2], <span class="o">[</span>B.c3], <span class="o">[</span>B.c1], <span class="o">[</span>B.v1], <span class="o">[</span>B.v2], <span class="o">[</span>B.v3], <span class="o">[</span>B.v4], <span class="o">[</span>B.v5], <span class="o">[</span>B.v6], <span class="o">[</span>B.v7], <span class="o">[</span>B.v8], <span class="o">[</span>B.v9]<span class="o">)</span>, filter<span class="o">([</span>? <span class="o">=</span> B.c2]<span class="o">)</span>,
  		access<span class="o">([</span>B.c2], <span class="o">[</span>B.c3], <span class="o">[</span>B.c1], <span class="o">[</span>B.v1], <span class="o">[</span>B.v2], <span class="o">[</span>B.v3], <span class="o">[</span>B.v4], <span class="o">[</span>B.v5], <span class="o">[</span>B.v6], <span class="o">[</span>B.v7], <span class="o">[</span>B.v8], <span class="o">[</span>B.v9]<span class="o">)</span>, partitions<span class="o">(</span>p0<span class="o">)</span>,
  		<span class="nv">is_index_back</span><span class="o">=</span><span class="nb">true</span>, filter_before_indexback[false],
  		range_key<span class="o">([</span>B.c3], <span class="o">[</span>B.c1]<span class="o">)</span>, range<span class="o">(</span>MIN <span class="p">;</span> MAX<span class="o">)</span>,
  		range_cond<span class="o">([</span>? <span class="o">=</span> B.c3]<span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>测试脚本</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">USER</span><span class="o">=</span>root@test
  <span class="nv">DB</span><span class="o">=</span><span class="nb">test
  </span><span class="nv">HOST</span><span class="o">=</span>127.0.0.1
  <span class="nv">PORT</span><span class="o">=</span>2881
  <span class="nv">THREADS</span><span class="o">=</span>128
  <span class="nv">TABLE_SIZE</span><span class="o">=</span>100000
  <span class="nv">TABLES</span><span class="o">=</span>3
  <span class="nv">TIME</span><span class="o">=</span>300
  <span class="nv">REPORT_INTERVAL</span><span class="o">=</span>10
    
  sysbench <span class="nt">--db-ps-mode</span><span class="o">=</span>disable <span class="nt">--mysql-host</span><span class="o">=</span><span class="nv">$HOST</span> <span class="nt">--mysql-port</span><span class="o">=</span><span class="nv">$PORT</span> <span class="se">\</span>
           <span class="nt">--rand-type</span><span class="o">=</span>uniform <span class="nt">--rand-seed</span><span class="o">=</span>26765 <span class="se">\</span>
           <span class="nt">--mysql-user</span><span class="o">=</span><span class="nv">$USER</span> <span class="nt">--mysql-db</span><span class="o">=</span><span class="nv">$DB</span> <span class="se">\</span>
           <span class="nt">--threads</span><span class="o">=</span><span class="nv">$THREADS</span> <span class="se">\</span>
           <span class="nt">--tables</span><span class="o">=</span><span class="nv">$TABLES</span> <span class="nt">--table_size</span><span class="o">=</span><span class="nv">$TABLE_SIZE</span> <span class="se">\</span>
           <span class="nt">--time</span><span class="o">=</span><span class="nv">$TIME</span> <span class="nt">--report-interval</span><span class="o">=</span><span class="nv">$REPORT_INTERVAL</span> <span class="se">\</span>
           subplan cleanup
    
  sysbench <span class="nt">--db-ps-mode</span><span class="o">=</span>disable <span class="nt">--mysql-host</span><span class="o">=</span><span class="nv">$HOST</span> <span class="nt">--mysql-port</span><span class="o">=</span><span class="nv">$PORT</span> <span class="se">\</span>
           <span class="nt">--rand-type</span><span class="o">=</span>uniform <span class="nt">--rand-seed</span><span class="o">=</span>26765 <span class="se">\</span>
           <span class="nt">--mysql-user</span><span class="o">=</span><span class="nv">$USER</span> <span class="nt">--mysql-db</span><span class="o">=</span><span class="nv">$DB</span> <span class="se">\</span>
           <span class="nt">--threads</span><span class="o">=</span><span class="nv">$THREADS</span> <span class="se">\</span>
           <span class="nt">--tables</span><span class="o">=</span><span class="nv">$TABLES</span> <span class="nt">--table_size</span><span class="o">=</span><span class="nv">$TABLE_SIZE</span> <span class="se">\</span>
           <span class="nt">--time</span><span class="o">=</span><span class="nv">$TIME</span> <span class="nt">--report-interval</span><span class="o">=</span><span class="nv">$REPORT_INTERVAL</span> <span class="se">\</span>
           subplan prepare
    
  sysbench <span class="nt">--db-ps-mode</span><span class="o">=</span>disable <span class="nt">--mysql-host</span><span class="o">=</span><span class="nv">$HOST</span> <span class="nt">--mysql-port</span><span class="o">=</span><span class="nv">$PORT</span> <span class="se">\</span>
           <span class="nt">--rand-type</span><span class="o">=</span>uniform <span class="nt">--rand-seed</span><span class="o">=</span>26765 <span class="se">\</span>
           <span class="nt">--mysql-user</span><span class="o">=</span><span class="nv">$USER</span> <span class="nt">--mysql-db</span><span class="o">=</span><span class="nv">$DB</span> <span class="se">\</span>
           <span class="nt">--threads</span><span class="o">=</span><span class="nv">$THREADS</span> <span class="se">\</span>
           <span class="nt">--tables</span><span class="o">=</span><span class="nv">$TABLES</span> <span class="nt">--table_size</span><span class="o">=</span><span class="nv">$TABLE_SIZE</span> <span class="se">\</span>
           <span class="nt">--time</span><span class="o">=</span><span class="nv">$TIME</span> <span class="nt">--report-interval</span><span class="o">=</span><span class="nv">$REPORT_INTERVAL</span> <span class="se">\</span>
           subplan run
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="性能调优">性能调优</h2>

<hr>

<ul>
  <li>
    <p>iotop</p>

    <p>首先看一下sysbench测试过程中，observer的磁盘IO情况，这里选用iotop来从系统/proc目录下读取进程的IO信息进行汇总。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">sudo </span>iotop <span class="nt">-o</span>
</code></pre></div>    </div>

    <p><img src="/auto-image/picrepo/2a9eed10-7bec-4c0f-b727-ee6629a1e4ab.png" alt="Untitled"></p>

    <p><img src="/auto-image/picrepo/0d7ad7c8-d6b3-4dc4-8316-abe9c4e94818.png" alt="Untitled"></p>

    <p><img src="/auto-image/picrepo/5d02b676-e41f-4629-99cc-820acdd1fd6b.png" alt="sysbench过程中observer的磁盘IO情况"></p>

    <p>sysbench过程中observer的磁盘IO情况</p>

    <p>可以看出在sysbench测试一段时间后，只有一些异步日志落盘和事务redo日志会产生写IO，读请求的内容不多，应该被cache在内存里了。再加上官方给的优化建议也是从内存优化入手，我们可以把重心放在内存优化上。</p>
  </li>
  <li>
    <p>perf</p>

    <p>perf是一个轻量级的profiling工具。perf top可以实时打印采样函数，显示出花费大部分CPU时间的函数。</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">sudo </span>perf top <span class="nt">-p</span> observer_pid
</code></pre></div>    </div>

    <p><img src="/auto-image/picrepo/1bd53e75-5d13-4fb0-918e-87d1772927fd.png" alt="perf top查看热点函数"></p>

    <p>perf top查看热点函数</p>

    <p>perf top返回的界面还可以交互，通过annotate跳进函数，还可以看到每个指令的耗时占比。不过返回的都是反汇编的结果，难以将其与源代码联系起来。</p>

    <p><img src="/auto-image/picrepo/6f23f286-d8cf-400a-974e-34c32623c488.png" alt="annotate查看函数每条指令的执行时间占比"></p>

    <p>annotate查看函数每条指令的执行时间占比</p>

    <p>perf stat还能看程序的branch-misses情况。</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  sudo perf stat -p observer_pid
</code></pre></div>    </div>

    <p><img src="/auto-image/picrepo/f3bd086f-7b88-425a-814b-871ae1a1a027.png" alt="Untitled"></p>
  </li>
  <li>
    <p>FlameGraph</p>

    <p>perf工具的采样结果需要在终端一个个点开函数才能看到调用栈的信息，比较难以对代码的执行流程有一个宏观上的认识，<a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a>能够帮助我们可视化perf采样的结果。</p>

    <p><img src="/auto-image/picrepo/eac60029-cc3f-4a36-a32d-0a9b661fbe3c.png" alt="NestedLoopJoin算子的三个主要部分"></p>

    <p>NestedLoopJoin算子的三个主要部分</p>

    <p>跑sysbench的同时跑一下火焰图，可以看到在NLJ的负载模式下，OceanBase的NestedLoopJoin物理算子执行流程主要包含三个部分（三个蓝色箭头指示），中间部分是对左表的扫描，右边部分是根据左表的每一行，先通过B.c3列（其实就是A.c3列的值）查询索引t2_i2，获取到rowkey后再查询t2，左边部分是左表每一行匹配完，与右表完成Join之后，会重置右表的扫描状态。</p>
  </li>
</ul>

<h2 id="一些优化点">一些优化点</h2>

<ul>
  <li>
    <p>优化右表回表逻辑</p>

    <p>右表会从索引表一次拿batch rowkeys，然后根据rowkeys数组通过ObMultipleGetMerge查询主表，从火焰图可以看出，这一块占了很大的比重。事实上，如果从索引表只拿到一个rowkey，可以使用ObSingleMerge查询主表，效率更高。</p>

    <p><img src="/auto-image/picrepo/446dc749-0f4b-43b2-8289-ed1f10740d2f.png" alt="原始代码的右表查索引表和回表过程"></p>

    <p>原始代码的右表查索引表和回表过程</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  diff --git a/src/storage/ob_index_merge.cpp b/src/storage/ob_index_merge.cpp
  index e6386773..82c59ba4 100644
  --- a/src/storage/ob_index_merge.cpp
  +++ b/src/storage/ob_index_merge.cpp
  @@ -30,7 +30,9 @@ ObIndexMerge::ObIndexMerge()
         rowkeys_(),
         rowkey_allocator_(ObModIds::OB_SSTABLE_GET_SCAN),
         rowkey_range_idx_(),
  -      index_range_array_cursor_(0)
  +      index_range_array_cursor_(0),
  +      table_iter_single_(),
  +      is_single_(0)
   {}
     
   ObIndexMerge::~ObIndexMerge()
  @@ -49,12 +51,20 @@ void ObIndexMerge::reset()
     rowkey_allocator_.reset();
     rowkey_range_idx_.reset();
     index_range_array_cursor_ = 0;
  +  if (is_single_) {
  +    table_iter_single_.reset();
  +    is_single_ = 0;
  +  }
   }
     
   void ObIndexMerge::reuse()
   {
     table_iter_.reuse();
     index_range_array_cursor_ = 0;
  +  // if (is_single_) {
  +  //   table_iter_single_.reuse();
  +  //   is_single_ = 0;
  +  // }
   }
     
   int ObIndexMerge::open(ObQueryRowIterator&amp; index_iter)
  @@ -71,11 +81,14 @@ int ObIndexMerge::init(const ObTableAccessParam&amp; param, const ObTableAccessParam
     int ret = OB_SUCCESS;
     if (OB_FAIL(table_iter_.init(param, context, get_table_param))) {
       STORAGE_LOG(WARN, "Fail to init table iter, ", K(ret));
  +  } else if (OB_FAIL(table_iter_single_.init(param, context, get_table_param))) {
  +    STORAGE_LOG(WARN, "Fail to init table single iter, ", K(ret));
     } else {
       index_param_ = &amp;index_param;
       access_ctx_ = &amp;context;
       rowkey_cnt_ = param.iter_param_.rowkey_cnt_;
     }
  +  is_single_ = 0;
     return ret;
   }
     
  @@ -107,7 +120,6 @@ int ObIndexMerge::get_next_row(ObStoreRow*&amp; row)
             ObExtStoreRowkey dest_key;
             rowkeys_.reuse();
             rowkey_allocator_.reuse();
  -          table_iter_.reuse();
             access_ctx_-&gt;allocator_-&gt;reuse();
             for (int64_t i = 0; OB_SUCC(ret) &amp;&amp; i &lt; MAX_NUM_PER_BATCH; ++i) {
               if (OB_FAIL(index_iter_-&gt;get_next_row(index_row))) {
  @@ -139,10 +151,21 @@ int ObIndexMerge::get_next_row(ObStoreRow*&amp; row)
             }
     
             if (OB_SUCC(ret)) {
  -            if (OB_FAIL(table_iter_.open(rowkeys_))) {
  -              STORAGE_LOG(WARN, "fail to open iterator", K(ret));
  +            if (1 == rowkeys_.count()) {
  +              table_iter_single_.reuse();
  +              is_single_ = 1;
  +              if (OB_FAIL(table_iter_single_.open(rowkeys_[0]))) {
  +                STORAGE_LOG(WARN, "fail to open iterator", K(ret));
  +              } else {
  +                main_iter_ = &amp;table_iter_single_;
  +              }
               } else {
  -              main_iter_ = &amp;table_iter_;
  +              table_iter_.reuse();
  +              if (OB_FAIL(table_iter_.open(rowkeys_))) {
  +                STORAGE_LOG(WARN, "fail to open iterator", K(ret));
  +              } else {
  +                main_iter_ = &amp;table_iter_;
  +              }
               }
             }
           }
  diff --git a/src/storage/ob_index_merge.h b/src/storage/ob_index_merge.h
  index e7a6cde5..cdeb0da1 100644
  --- a/src/storage/ob_index_merge.h
  +++ b/src/storage/ob_index_merge.h
  @@ -19,6 +19,7 @@
   #include "storage/ob_multiple_get_merge.h"
   #include "storage/ob_query_iterator_util.h"
   #include "storage/blocksstable/ob_block_sstable_struct.h"
  +#include "storage/ob_single_merge.h"
     
   namespace oceanbase {
   namespace storage {
  @@ -50,6 +51,8 @@ class ObIndexMerge : public ObQueryRowIterator {
     common::ObArenaAllocator rowkey_allocator_;
     ObArray&lt;int64_t&gt; rowkey_range_idx_;
     int64_t index_range_array_cursor_;
  +  ObSingleMerge table_iter_single_;
  +  int is_single_;
     
   private:
     DISALLOW_COPY_AND_ASSIGN(ObIndexMerge);
  diff --git a/src/storage/ob_single_merge.cpp b/src/storage/ob_single_merge.cpp
  index 42a34425..3c76aa0f 100644
  --- a/src/storage/ob_single_merge.cpp
  +++ b/src/storage/ob_single_merge.cpp
  @@ -141,9 +141,10 @@ int ObSingleMerge::inner_get_next_row(ObStoreRow&amp; row)
       int64_t end_table_idx = 0;
       int64_t row_cache_snapshot_version = 0;
       const ObIArray&lt;ObITable*&gt;&amp; tables = tables_handle_.get_tables();
  -    const bool enable_fuse_row_cache = is_x86() &amp;&amp; access_ctx_-&gt;use_fuse_row_cache_ &amp;&amp;
  -                                       access_param_-&gt;iter_param_.enable_fuse_row_cache() &amp;&amp;
  -                                       access_ctx_-&gt;fuse_row_cache_hit_rate_ &gt; 6;
  +    // const bool enable_fuse_row_cache = is_x86() &amp;&amp; access_ctx_-&gt;use_fuse_row_cache_ &amp;&amp;
  +    //                                    access_param_-&gt;iter_param_.enable_fuse_row_cache() &amp;&amp;
  +    //                                    access_ctx_-&gt;fuse_row_cache_hit_rate_ &gt; 6;
  +    const bool enable_fuse_row_cache = false;
       access_ctx_-&gt;query_flag_.set_not_use_row_cache();
       const int64_t table_cnt = tables.count();
       ObITable* table = NULL;
</code></pre></div>    </div>

    <p><img src="/auto-image/picrepo/353362bb-1b37-411c-8fcf-b510231d8427.png" alt="rowkey为1时使用SingleMerge回表"></p>

    <p>rowkey为1时使用SingleMerge回表</p>
  </li>
  <li>
    <p>rescan过程中尽量少进行对象析构</p>

    <p>从火焰图中可以看出，reuse_row_iters会析构掉很多对象，优化思路是保证这些被析构的对象在整个查询过程中始终内存有效，并且每次rescan时重置一些状态。</p>

    <p><img src="/auto-image/picrepo/b5f00979-65b3-4d3b-b771-067faf285e27.png" alt="reuse row iters的内容"></p>

    <p>reuse row iters的内容</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  diff --git a/src/storage/memtable/ob_memtable.cpp b/src/storage/memtable/ob_memtable.cpp
  index 3a4d28f7..ba7d295d 100644
  --- a/src/storage/memtable/ob_memtable.cpp
  +++ b/src/storage/memtable/ob_memtable.cpp
  @@ -1033,7 +1033,7 @@ int ObMemtable::get(const storage::ObTableIterParam&amp; param, storage::ObTableAcce
       TRANS_LOG(WARN, "invalid argument, ", K(ret), K(param), K(context));
     } else if (OB_FAIL(context.store_ctx_-&gt;mem_ctx_-&gt;get_trans_status())) {
       TRANS_LOG(WARN, "trans already end", K(ret));
  -  } else if (NULL == (get_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableGetIterator))) ||
  +  } else if (NULL == (get_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableGetIterator))) ||
                NULL == (get_iter_ptr = new (get_iter_buffer) ObMemtableGetIterator())) {
       TRANS_LOG(WARN, "construct ObMemtableGetIterator fail");
       ret = OB_ALLOCATE_MEMORY_FAILED;
  @@ -1082,7 +1082,7 @@ int ObMemtable::scan(const storage::ObTableIterParam&amp; param, storage::ObTableAcc
     } else {
       if (param.is_multi_version_minor_merge_) {
         if (GCONF._enable_sparse_row) {
  -        if (NULL == (scan_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableMultiVersionScanSparseIterator))) ||
  +        if (NULL == (scan_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableMultiVersionScanSparseIterator))) ||
               NULL == (scan_iter_ptr = new (scan_iter_buffer) ObMemtableMultiVersionScanSparseIterator())) {
             TRANS_LOG(WARN,
                 "construct ObMemtableMultiVersionScanSparseIterator fail",
  @@ -1099,7 +1099,7 @@ int ObMemtable::scan(const storage::ObTableIterParam&amp; param, storage::ObTableAcc
             TRANS_LOG(WARN, "scan iter init fail", "ret", ret, K(real_range), K(param), K(context));
           }
         } else {
  -        if (NULL == (scan_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableMultiVersionScanIterator))) ||
  +        if (NULL == (scan_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableMultiVersionScanIterator))) ||
               NULL == (scan_iter_ptr = new (scan_iter_buffer) ObMemtableMultiVersionScanIterator())) {
             TRANS_LOG(WARN,
                 "construct ObMemtableScanIterator fail",
  @@ -1117,7 +1117,7 @@ int ObMemtable::scan(const storage::ObTableIterParam&amp; param, storage::ObTableAcc
           }
         }
       } else {
  -      if (NULL == (scan_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableScanIterator))) ||
  +      if (NULL == (scan_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableScanIterator))) ||
             NULL == (scan_iter_ptr = new (scan_iter_buffer) ObMemtableScanIterator())) {
           TRANS_LOG(WARN,
               "construct ObMemtableScanIterator fail",
  @@ -1162,7 +1162,7 @@ int ObMemtable::multi_get(const storage::ObTableIterParam&amp; param, storage::ObTab
       TRANS_LOG(WARN, "invalid argument, ", K(ret), K(param), K(context), K(rowkeys));
     } else if (OB_FAIL(context.store_ctx_-&gt;mem_ctx_-&gt;get_trans_status())) {
       TRANS_LOG(WARN, "trans already end", K(ret));
  -  } else if (NULL == (mget_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableMGetIterator))) ||
  +  } else if (NULL == (mget_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableMGetIterator))) ||
                NULL == (mget_iter_ptr = new (mget_iter_buffer) ObMemtableMGetIterator())) {
       TRANS_LOG(WARN,
           "construct ObMemtableMGetIterator fail",
  @@ -1212,7 +1212,7 @@ int ObMemtable::multi_scan(const storage::ObTableIterParam&amp; param, storage::ObTa
       TRANS_LOG(WARN, "invalid argument, ", K(ret), K(param), K(context), K(ranges));
     } else if (OB_FAIL(context.store_ctx_-&gt;mem_ctx_-&gt;get_trans_status())) {
       TRANS_LOG(WARN, "trans already end", K(ret));
  -  } else if (NULL == (mscan_iter_buffer = context.allocator_-&gt;alloc(sizeof(ObMemtableMScanIterator))) ||
  +  } else if (NULL == (mscan_iter_buffer = context.stmt_allocator_-&gt;alloc(sizeof(ObMemtableMScanIterator))) ||
                NULL == (mscan_iter_ptr = new (mscan_iter_buffer) ObMemtableMScanIterator())) {
       TRANS_LOG(WARN,
           "construct ObMemtableMScanIterator fail",
  diff --git a/src/storage/ob_i_store.h b/src/storage/ob_i_store.h
  index e13283f7..69971590 100644
  --- a/src/storage/ob_i_store.h
  +++ b/src/storage/ob_i_store.h
  @@ -833,6 +833,8 @@ public:
     }
     virtual void reuse()
     {}
  +  virtual void reset()
  +  {}
     virtual bool is_base_sstable_iter() const
     {
       return false;
  diff --git a/src/storage/ob_multiple_get_merge.cpp b/src/storage/ob_multiple_get_merge.cpp
  index ebfd26a7..c5686543 100644
  --- a/src/storage/ob_multiple_get_merge.cpp
  +++ b/src/storage/ob_multiple_get_merge.cpp
  @@ -82,7 +82,7 @@ void ObMultipleGetMerge::reset_with_fuse_row_cache()
       handles_ = nullptr;
     }
     prefetch_cnt_ = 0;
  -  reuse_iter_array();
  +  reset_iter_array();
   }
     
   void ObMultipleGetMerge::reset()
  diff --git a/src/storage/ob_multiple_merge.cpp b/src/storage/ob_multiple_merge.cpp
  index be8de75f..f5c92405 100644
  --- a/src/storage/ob_multiple_merge.cpp
  +++ b/src/storage/ob_multiple_merge.cpp
  @@ -505,6 +505,10 @@ void ObMultipleMerge::reset()
       if (NULL != (iter = iters_.at(i))) {
         iter-&gt;~ObStoreRowIterator();
       }
  +    if (OB_NOT_NULL(access_ctx_-&gt;stmt_allocator_)) {
  +      access_ctx_-&gt;stmt_allocator_-&gt;free(iter);
  +    }
  +    iter = NULL;
     }
     padding_allocator_.reset();
     iters_.reset();
  @@ -541,17 +545,31 @@ void ObMultipleMerge::reuse()
     read_memtable_only_ = false;
   }
     
  -void ObMultipleMerge::reuse_iter_array()
  +void ObMultipleMerge::reset_iter_array()
   {
     ObStoreRowIterator* iter = NULL;
     for (int64_t i = 0; i &lt; iters_.count(); ++i) {
       if (NULL != (iter = iters_.at(i))) {
         iter-&gt;~ObStoreRowIterator();
       }
  +    if (OB_NOT_NULL(access_ctx_-&gt;stmt_allocator_)) {
  +      access_ctx_-&gt;stmt_allocator_-&gt;free(iter);
  +    }
  +    iter = NULL;
     }
     iters_.reuse();
   }
     
  +void ObMultipleMerge::reuse_iter_array()
  +{
  +  ObStoreRowIterator* iter = NULL;
  +  for (int64_t i = 0; i &lt; iters_.count(); ++i) {
  +    if (NULL != (iter = iters_.at(i))) {
  +      iter-&gt;reuse();
  +    }
  +  }
  +}
  +
   int ObMultipleMerge::open()
   {
     int ret = OB_SUCCESS;
  @@ -946,7 +964,7 @@ int ObMultipleMerge::refresh_table_on_demand()
     } else if (need_refresh) {
       if (OB_FAIL(save_curr_rowkey())) {
         STORAGE_LOG(WARN, "fail to save current rowkey", K(ret));
  -    } else if (FALSE_IT(reuse_iter_array())) {
  +    } else if (FALSE_IT(reset_iter_array())) {
       } else if (OB_FAIL(prepare_read_tables())) {
         STORAGE_LOG(WARN, "fail to prepare read tables", K(ret));
       } else if (OB_FAIL(reset_tables())) {
  diff --git a/src/storage/ob_multiple_merge.h b/src/storage/ob_multiple_merge.h
  index ed227202..a560172d 100644
  --- a/src/storage/ob_multiple_merge.h
  +++ b/src/storage/ob_multiple_merge.h
  @@ -80,6 +80,7 @@ protected:
     const ObTableIterParam* get_actual_iter_param(const ObITable* table) const;
     int project_row(const ObStoreRow&amp; unprojected_row, const common::ObIArray&lt;int32_t&gt;* projector,
         const int64_t range_idx_delta, ObStoreRow&amp; projected_row);
  +  void reset_iter_array();
     void reuse_iter_array();
     virtual int skip_to_range(const int64_t range_idx);
     
  diff --git a/src/storage/ob_sstable.cpp b/src/storage/ob_sstable.cpp
  index 13a3f0fa..c0713bbc 100644
  --- a/src/storage/ob_sstable.cpp
  +++ b/src/storage/ob_sstable.cpp
  @@ -1105,14 +1105,14 @@ int ObSSTable::get(const storage::ObTableIterParam&amp; param, storage::ObTableAcces
       ObISSTableRowIterator* row_getter = NULL;
       if (is_multi_version_minor_sstable() &amp;&amp; (context.is_multi_version_read(get_upper_trans_version()) ||
                                                   contain_uncommitted_row() || !meta_.has_compact_row_)) {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowGetter)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowGetter)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
           row_getter = new (buf) ObSSTableMultiVersionRowGetter();
         }
       } else {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableRowGetter)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableRowGetter)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
  @@ -1163,14 +1163,14 @@ int ObSSTable::multi_get(const ObTableIterParam&amp; param, ObTableAccessContext&amp; co
         ObISSTableRowIterator* row_getter = NULL;
         if (is_multi_version_minor_sstable() &amp;&amp; (context.is_multi_version_read(get_upper_trans_version()) ||
                                                     contain_uncommitted_row() || !meta_.has_compact_row_)) {
  -        if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowMultiGetter)))) {
  +        if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowMultiGetter)))) {
             ret = OB_ALLOCATE_MEMORY_FAILED;
             STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
           } else {
             row_getter = new (buf) ObSSTableMultiVersionRowMultiGetter();
           }
         } else {
  -        if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableRowMultiGetter)))) {
  +        if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableRowMultiGetter)))) {
             ret = OB_ALLOCATE_MEMORY_FAILED;
             STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
           } else {
  @@ -1269,21 +1269,21 @@ int ObSSTable::scan(const ObTableIterParam&amp; param, ObTableAccessContext&amp; context
       void* buf = NULL;
       ObISSTableRowIterator* row_scanner = NULL;
       if (context.query_flag_.is_whole_macro_scan()) {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableRowWholeScanner)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableRowWholeScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
           row_scanner = new (buf) ObSSTableRowWholeScanner();
         }
       } else if (is_multi_version_minor_sstable()) {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowScanner)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
           row_scanner = new (buf) ObSSTableMultiVersionRowScanner();
         }
       } else {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableRowScanner)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableRowScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
  @@ -1435,14 +1435,14 @@ int ObSSTable::multi_scan(const ObTableIterParam&amp; param, ObTableAccessContext&amp; c
       void* buf = NULL;
       ObISSTableRowIterator* row_scanner = NULL;
       if (is_multi_version_minor_sstable()) {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowMultiScanner)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableMultiVersionRowMultiScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
           row_scanner = new (buf) ObSSTableMultiVersionRowMultiScanner();
         }
       } else {
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ObSSTableRowMultiScanner)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ObSSTableRowMultiScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
  diff --git a/src/storage/ob_sstable_row_iterator.cpp b/src/storage/ob_sstable_row_iterator.cpp
  index 27c89147..cc0d2dd5 100644
  --- a/src/storage/ob_sstable_row_iterator.cpp
  +++ b/src/storage/ob_sstable_row_iterator.cpp
  @@ -1539,7 +1539,7 @@ int ObSSTableRowIterator::alloc_micro_getter()
     int ret = OB_SUCCESS;
     void* buf = NULL;
     if (NULL == micro_getter_) {
  -    if (NULL == (buf = access_ctx_-&gt;allocator_-&gt;alloc(sizeof(ObMicroBlockRowGetter)))) {
  +    if (NULL == (buf = access_ctx_-&gt;stmt_allocator_-&gt;alloc(sizeof(ObMicroBlockRowGetter)))) {
         ret = OB_ALLOCATE_MEMORY_FAILED;
         STORAGE_LOG(WARN, "Fail to allocate memory, ", K(ret));
       } else {
  @@ -1572,14 +1572,14 @@ int ObSSTableRowIterator::open_cur_micro_block(ObSSTableReadHandle&amp; read_handle,
     if (NULL == micro_scanner_) {
       // alloc scanner
       if (!sstable_-&gt;is_multi_version_minor_sstable()) {
  -      if (NULL == (buf = access_ctx_-&gt;allocator_-&gt;alloc(sizeof(ObMicroBlockRowScanner)))) {
  +      if (NULL == (buf = access_ctx_-&gt;stmt_allocator_-&gt;alloc(sizeof(ObMicroBlockRowScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory for micro block scanner, ", K(ret));
         } else {
           micro_scanner_ = new (buf) ObMicroBlockRowScanner();
         }
       } else {
  -      if (NULL == (buf = access_ctx_-&gt;allocator_-&gt;alloc(sizeof(ObMultiVersionMicroBlockRowScanner)))) {
  +      if (NULL == (buf = access_ctx_-&gt;stmt_allocator_-&gt;alloc(sizeof(ObMultiVersionMicroBlockRowScanner)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           STORAGE_LOG(WARN, "Fail to allocate memory for micro block scanner, ", K(ret));
         } else {
    
  diff --git a/src/storage/memtable/ob_memtable.cpp b/src/storage/memtable/ob_memtable.cpp
  index ba7d295d..d1a02dc1 100644
  --- a/src/storage/memtable/ob_memtable.cpp
  +++ b/src/storage/memtable/ob_memtable.cpp
  @@ -1048,6 +1048,7 @@ int ObMemtable::get(const storage::ObTableIterParam&amp; param, storage::ObTableAcce
     if (OB_FAIL(ret)) {
       if (NULL != get_iter_ptr) {
         get_iter_ptr-&gt;~ObMemtableGetIterator();
  +      context.stmt_allocator_-&gt;free(get_iter_ptr);
         get_iter_ptr = NULL;
       }
       TRANS_LOG(WARN, "get fail", K(ret), K_(key), K(param.table_id_));
  @@ -1139,6 +1140,7 @@ int ObMemtable::scan(const storage::ObTableIterParam&amp; param, storage::ObTableAcc
       } else {
         if (NULL != scan_iter_ptr) {
           scan_iter_ptr-&gt;~ObIMemtableScanIterator();
  +        context.stmt_allocator_-&gt;free(scan_iter_ptr);
           scan_iter_ptr = NULL;
         }
         TRANS_LOG(
  @@ -1182,6 +1184,7 @@ int ObMemtable::multi_get(const storage::ObTableIterParam&amp; param, storage::ObTab
     if (OB_FAIL(ret)) {
       if (NULL != mget_iter_ptr) {
         mget_iter_ptr-&gt;~ObMemtableMGetIterator();
  +      context.stmt_allocator_-&gt;free(mget_iter_ptr);
         mget_iter_ptr = NULL;
       }
       TRANS_LOG(WARN,
  @@ -1233,6 +1236,7 @@ int ObMemtable::multi_scan(const storage::ObTableIterParam&amp; param, storage::ObTa
     if (OB_FAIL(ret)) {
       if (NULL != mscan_iter_ptr) {
         mscan_iter_ptr-&gt;~ObMemtableMScanIterator();
  +      context.stmt_allocator_-&gt;free(mscan_iter_ptr);
         mscan_iter_ptr = NULL;
       }
       TRANS_LOG(WARN,
  diff --git a/src/storage/ob_multiple_merge.cpp b/src/storage/ob_multiple_merge.cpp
  index f5c92405..6426010c 100644
  --- a/src/storage/ob_multiple_merge.cpp
  +++ b/src/storage/ob_multiple_merge.cpp
  @@ -993,7 +993,7 @@ int ObMultipleMerge::release_table_ref()
       STORAGE_LOG(WARN, "fail to check need refresh table", K(ret));
     } else if (need_refresh) {
       tables_handle_.reset();
  -    reuse_iter_array();
  +    reset_iter_array();
       is_tables_reset_ = true;
       STORAGE_LOG(INFO, "table need to be released", "table_id", access_param_-&gt;iter_param_.table_id_,
           K(*access_param_), K(curr_scan_index_));
  diff --git a/src/storage/ob_sstable_multi_version_row_iterator.cpp b/src/storage/ob_sstable_multi_version_row_iterator.cpp
  index 95b94b11..e295ccee 100644
  --- a/src/storage/ob_sstable_multi_version_row_iterator.cpp
  +++ b/src/storage/ob_sstable_multi_version_row_iterator.cpp
  @@ -57,10 +57,13 @@ void ObSSTableMultiVersionRowIterator::reset()
     
   void ObSSTableMultiVersionRowIterator::reuse()
   {
  -  ObISSTableRowIterator::reuse();
  +  ObISSTableRowIterator::reset();
  +  // ObISSTableRowIterator::reuse();
     query_range_ = NULL;
     if (NULL != iter_) {
  -    iter_-&gt;reuse();
  +    // iter_-&gt;reuse();
  +    iter_-&gt;~ObSSTableRowIterator();
  +    iter_ = NULL;
     }
     out_cols_cnt_ = 0;
     range_idx_ = 0;
  @@ -123,7 +126,7 @@ int ObSSTableMultiVersionRowGetter::inner_open(
       if (OB_FAIL(ObVersionStoreRangeConversionHelper::store_rowkey_to_multi_version_range(
               *rowkey_, access_ctx.trans_version_range_, *access_ctx.allocator_, multi_version_range_))) {
         LOG_WARN("convert to multi version range failed", K(ret), K(*rowkey_));
  -    } else if (OB_FAIL(new_iterator&lt;ObSSTableRowScanner&gt;(*access_ctx.allocator_))) {
  +    } else if (OB_FAIL(new_iterator&lt;ObSSTableRowScanner&gt;(*access_ctx.stmt_allocator_))) {
         LOG_WARN("failed to new iterator", K(ret));
       } else if (OB_FAIL(iter_-&gt;init(iter_param, access_ctx, table, &amp;multi_version_range_))) {
         LOG_WARN("failed to open scanner", K(ret));
  @@ -213,7 +216,7 @@ int ObSSTableMultiVersionRowScanner::inner_open(
       if (OB_FAIL(ObVersionStoreRangeConversionHelper::range_to_multi_version_range(
               *range_, access_ctx.trans_version_range_, *access_ctx.allocator_, multi_version_range_))) {
         LOG_WARN("convert to multi version range failed", K(ret), K(*range_));
  -    } else if (OB_FAIL(new_iterator&lt;ObSSTableRowScanner&gt;(*access_ctx.allocator_))) {
  +    } else if (OB_FAIL(new_iterator&lt;ObSSTableRowScanner&gt;(*access_ctx.stmt_allocator_))) {
         LOG_WARN("failed to new iterator", K(ret));
       } else if (OB_FAIL(iter_-&gt;init(iter_param, access_ctx, table, &amp;multi_version_range_))) {
         LOG_WARN("failed to open scanner", K(ret));
  @@ -306,7 +309,7 @@ int ObSSTableMultiVersionRowMultiGetter::inner_open(
           }
         }
         if (OB_FAIL(ret)) {
  -      } else if (OB_FAIL(new_iterator&lt;ObSSTableRowMultiScanner&gt;(*access_ctx.allocator_))) {
  +      } else if (OB_FAIL(new_iterator&lt;ObSSTableRowMultiScanner&gt;(*access_ctx.stmt_allocator_))) {
           LOG_WARN("failed to new iterator", K(ret));
         } else if (OB_FAIL(iter_-&gt;init(iter_param, access_ctx, table, &amp;multi_version_ranges_))) {
           LOG_WARN("failed to open multi scanner", K(ret));
  @@ -431,7 +434,7 @@ int ObSSTableMultiVersionRowMultiScanner::inner_open(
         }
     
         if (OB_FAIL(ret)) {
  -      } else if (OB_FAIL(new_iterator&lt;ObSSTableRowMultiScanner&gt;(*access_ctx.allocator_))) {
  +      } else if (OB_FAIL(new_iterator&lt;ObSSTableRowMultiScanner&gt;(*access_ctx.stmt_allocator_))) {
           LOG_WARN("failed to new iterator", K(ret));
         } else if (OB_FAIL(iter_-&gt;init(iter_param, access_ctx, table, &amp;multi_version_ranges_))) {
           LOG_WARN("failed to open scanner", K(ret));
    
  diff --git a/src/storage/ob_sstable_row_iterator.cpp b/src/storage/ob_sstable_row_iterator.cpp
  index cc0d2dd5..acc43774 100644
  --- a/src/storage/ob_sstable_row_iterator.cpp
  +++ b/src/storage/ob_sstable_row_iterator.cpp
  @@ -469,13 +469,13 @@ int ObSSTableRowIterator::inner_open(
       STORAGE_LOG(WARN, "Unexpected error, ", K(ret), K_(read_handle_cnt), K_(micro_handle_cnt));
     } else if (OB_FAIL(init_handle_mgr(iter_param, access_ctx, query_range))) {
       STORAGE_LOG(WARN, "fail to init handle mgr", K(ret), K(iter_param), K(access_ctx));
  -  } else if (OB_FAIL(read_handles_.reserve(*access_ctx.allocator_, read_handle_cnt_))) {
  +  } else if (OB_FAIL(read_handles_.reserve(*access_ctx.stmt_allocator_, read_handle_cnt_))) {
       STORAGE_LOG(WARN, "failed to reserve read handles", K(ret), K_(read_handle_cnt));
  -  } else if (OB_FAIL(micro_handles_.reserve(*access_ctx.allocator_, micro_handle_cnt_))) {
  +  } else if (OB_FAIL(micro_handles_.reserve(*access_ctx.stmt_allocator_, micro_handle_cnt_))) {
       STORAGE_LOG(WARN, "failed to reserve micro handles", K(ret), K_(micro_handle_cnt));
  -  } else if (OB_FAIL(sstable_micro_infos_.reserve(*access_ctx.allocator_, micro_handle_cnt_))) {
  +  } else if (OB_FAIL(sstable_micro_infos_.reserve(*access_ctx.stmt_allocator_, micro_handle_cnt_))) {
       STORAGE_LOG(WARN, "failed to reserve sstable micro infos", K(ret), K_(micro_handle_cnt));
  -  } else if (OB_FAIL(sorted_sstable_micro_infos_.reserve(*access_ctx.allocator_, micro_handle_cnt_))) {
  +  } else if (OB_FAIL(sorted_sstable_micro_infos_.reserve(*access_ctx.stmt_allocator_, micro_handle_cnt_))) {
       STORAGE_LOG(WARN, "failed to reserve sorted sstable micro infos", K(ret), K_(micro_handle_cnt));
     } else {
       sstable_ = static_cast&lt;ObSSTable*&gt;(table);
    
  diff --git a/src/storage/ob_multiple_multi_scan_merge.cpp b/src/storage/ob_multiple_multi_scan_merge.cpp
  index a7b2a571..55bdabd8 100644
  --- a/src/storage/ob_multiple_multi_scan_merge.cpp
  +++ b/src/storage/ob_multiple_multi_scan_merge.cpp
  @@ -228,7 +228,7 @@ int ObMultipleMultiScanMerge::construct_iters()
             iter-&gt;~ObStoreRowIterator();
             STORAGE_LOG(WARN, "Fail to push iter to iterator array, ", K(ret), K(i));
           }
  -      } else if (OB_ISNULL(iters_.at(tables.count() - 1 - i))) {
  +      } else if (OB_ISNULL(iter = iters_.at(tables.count() - 1 - i))) {
           ret = OB_ERR_UNEXPECTED;
           STORAGE_LOG(WARN, "Unexpected null iter", K(ret), "idx", tables.count() - 1 - i, K_(iters));
         } else if (OB_FAIL(iter-&gt;init(*iter_param, *access_ctx_, table, ranges_))) {
    
  diff --git a/src/storage/blocksstable/ob_micro_block_row_scanner.cpp b/src/storage/blocksstable/ob_micro_block_row_scanner.cpp
  index d6fd2648..cdc0297f 100644
  --- a/src/storage/blocksstable/ob_micro_block_row_scanner.cpp
  +++ b/src/storage/blocksstable/ob_micro_block_row_scanner.cpp
  @@ -445,7 +445,7 @@ int ObMicroBlockRowScanner::init(const ObTableIterParam&amp; param, ObTableAccessCon
       STORAGE_LOG(WARN, "fail to get projector", K(ret));
     } else if (OB_FAIL(param_-&gt;get_column_map(false /*is get*/, column_id_map))) {
       STORAGE_LOG(WARN, "fail to get column id map", K(ret));
  -  } else if (OB_FAIL(column_map_.init(*context_-&gt;allocator_,
  +  } else if (OB_FAIL(column_map_.init(*context_-&gt;stmt_allocator_,
                    param_-&gt;schema_version_,
                    param_-&gt;rowkey_cnt_,
                    0, /*store count*/
  @@ -573,7 +573,7 @@ int ObMultiVersionMicroBlockRowScanner::init(
       STORAGE_LOG(WARN, "fail to get projector", K(ret));
     } else if (OB_FAIL(param_-&gt;get_column_map(context.use_fuse_row_cache_, column_id_map))) {
       STORAGE_LOG(WARN, "fail to get column id map", K(ret));
  -  } else if (OB_FAIL(column_map_.init(*context_-&gt;allocator_,
  +  } else if (OB_FAIL(column_map_.init(*context_-&gt;stmt_allocator_,
                    param_-&gt;schema_version_,
                    param_-&gt;rowkey_cnt_,
                    0, /*store count*/
  @@ -1358,7 +1358,7 @@ int ObMultiVersionMicroBlockMinorMergeRowScanner::init(
       // minor merge should contain 2
       if (OB_FAIL(build_minor_merge_out_cols(*param_, out_cols, expect_multi_version_col_cnt))) {
         STORAGE_LOG(WARN, "fail to build minor merge out columns", K(ret));
  -    } else if (OB_FAIL(column_map_.init(*context_-&gt;allocator_,
  +    } else if (OB_FAIL(column_map_.init(*context_-&gt;stmt_allocator_,
                      param_-&gt;schema_version_,
                      param_-&gt;rowkey_cnt_,
                      0, /*store count*/
  diff --git a/src/storage/memtable/ob_memtable.cpp b/src/storage/memtable/ob_memtable.cpp
  index d1a02dc1..94050470 100644
  --- a/src/storage/memtable/ob_memtable.cpp
  +++ b/src/storage/memtable/ob_memtable.cpp
  @@ -927,7 +927,7 @@ int ObMemtable::get(const storage::ObTableIterParam&amp; param, storage::ObTableAcce
       const ColumnMap* param_column_map = nullptr;
       if (nullptr == row.row_val_.cells_) {
         if (nullptr ==
  -          (row.row_val_.cells_ = static_cast&lt;ObObj*&gt;(context.allocator_-&gt;alloc(sizeof(ObObj) * out_cols-&gt;count())))) {
  +          (row.row_val_.cells_ = static_cast&lt;ObObj*&gt;(context.stmt_allocator_-&gt;alloc(sizeof(ObObj) * out_cols-&gt;count())))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           TRANS_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
  @@ -940,11 +940,11 @@ int ObMemtable::get(const storage::ObTableIterParam&amp; param, storage::ObTableAcce
         TRANS_LOG(WARN, "fail to get column map", K(ret));
       } else if (NULL == param_column_map) {
         void* buf = NULL;
  -      if (NULL == (buf = context.allocator_-&gt;alloc(sizeof(ColumnMap)))) {
  +      if (NULL == (buf = context.stmt_allocator_-&gt;alloc(sizeof(ColumnMap)))) {
           ret = OB_ALLOCATE_MEMORY_FAILED;
           TRANS_LOG(WARN, "Fail to allocate memory, ", K(ret));
         } else {
  -        local_map = new (buf) ColumnMap(*context.allocator_);
  +        local_map = new (buf) ColumnMap(*context.stmt_allocator_);
           if (OB_FAIL(local_map-&gt;init(*out_cols))) {
             TRANS_LOG(WARN, "Fail to build column map, ", K(ret));
           }
</code></pre></div>    </div>
  </li>
  <li>
    <p>复用handle mgr</p>

    <p>ObSSTableRowIterator中使用了block_handle_mgr_和block_index_handle_mgr_来缓存访问到的block_handle和block_index_handle，可以识别出rescan场景并且保持mgr一直有效。</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  diff --git a/src/storage/ob_i_store.h b/src/storage/ob_i_store.h
  index 69971590..eb5274c9 100644
  --- a/src/storage/ob_i_store.h
  +++ b/src/storage/ob_i_store.h
  @@ -785,7 +785,7 @@ public:
     
   class ObStoreRowIterator : public ObIStoreRowIterator {
   public:
  -  ObStoreRowIterator() : type_(0)
  +  ObStoreRowIterator() : type_(0), is_rescan_(false)
     {}
     virtual ~ObStoreRowIterator()
     {}
  @@ -855,8 +855,14 @@ public:
     }
     VIRTUAL_TO_STRING_KV(K_(type));
     
  +  virtual void set_rescan_true()
  +  {
  +     is_rescan_ = true;
  +  }
  +
   protected:
     int type_;
  +  int is_rescan_;
     
   private:
     DISALLOW_COPY_AND_ASSIGN(ObStoreRowIterator);
  diff --git a/src/storage/ob_multiple_scan_merge.cpp b/src/storage/ob_multiple_scan_merge.cpp
  index 958c335e..130b53e9 100644
  --- a/src/storage/ob_multiple_scan_merge.cpp
  +++ b/src/storage/ob_multiple_scan_merge.cpp
  @@ -160,6 +160,9 @@ int ObMultipleScanMerge::construct_iters()
           }
           STORAGE_LOG(DEBUG, "[PUSHDOWN]", K_(consumer), K(iter-&gt;is_base_sstable_iter()));
           STORAGE_LOG(DEBUG, "add iter for consumer", KPC(table), KPC(access_param_));
  +        if (is_rescan()) {
  +          iter-&gt;set_rescan_true();
  +        }
         }
       }
     
  diff --git a/src/storage/ob_sstable_row_iterator.cpp b/src/storage/ob_sstable_row_iterator.cpp
  index a09c3e30..0fe498ae 100644
  --- a/src/storage/ob_sstable_row_iterator.cpp
  +++ b/src/storage/ob_sstable_row_iterator.cpp
  @@ -218,6 +218,7 @@ void ObISSTableRowIterator::reset()
     batch_rows_ = NULL;
     batch_row_count_ = 0;
     batch_row_pos_ = 0;
  +  is_rescan_ = false;
   }
     
   void ObISSTableRowIterator::reuse()
  @@ -428,7 +429,8 @@ ObSSTableRowIterator::ObSSTableRowIterator()
         io_micro_infos_(),
         micro_info_iter_(),
         prefetch_handle_depth_(DEFAULT_PREFETCH_HANDLE_DEPTH),
  -      prefetch_micro_depth_(DEFAULT_PREFETCH_MICRO_DEPTH)
  +      prefetch_micro_depth_(DEFAULT_PREFETCH_MICRO_DEPTH),
  +      hdr_flag_(0)
   {}
     
   ObSSTableRowIterator::~ObSSTableRowIterator()
  @@ -640,6 +642,7 @@ void ObSSTableRowIterator::reset()
     storage_file_ = nullptr;
     prefetch_handle_depth_ = DEFAULT_PREFETCH_HANDLE_DEPTH;
     prefetch_micro_depth_ = DEFAULT_PREFETCH_MICRO_DEPTH;
  +  hdr_flag_ = 0;
   }
     
   void ObSSTableRowIterator::reuse()
  @@ -666,8 +669,6 @@ void ObSSTableRowIterator::reuse()
     cur_range_idx_ = -1;
     io_micro_infos_.reuse();
     micro_info_iter_.reuse();
  -  block_index_handle_mgr_.reset();
  -  block_handle_mgr_.reset();
     table_store_stat_.reuse();
     skip_ctx_.reset();
     storage_file_ = nullptr;
  @@ -1683,6 +1684,29 @@ int ObSSTableRowIterator::init_handle_mgr(
       const ObTableIterParam&amp; iter_param, ObTableAccessContext&amp; access_ctx, const void* query_range)
   {
     int ret = OB_SUCCESS;
  +  if (is_rescan_) {
  +    if (hdr_flag_ == 0) {
  +      block_index_handle_mgr_.reset();
  +      block_handle_mgr_.reset();
  +      if (OB_FAIL(block_handle_mgr_.init(true, true, *access_ctx.stmt_allocator_))) {
  +        STORAGE_LOG(WARN, "failed to init block handle mgr", K(ret), K(true), K(true)); 
  +      } else if (OB_FAIL(block_index_handle_mgr_.init(true, true, *access_ctx.stmt_allocator_))) {
  +        STORAGE_LOG(WARN, "failed to init block index handle mgr", K(ret), K(true), K(true));
  +      }
  +      hdr_flag_ = 1;
  +    }
  +    return ret;
  +  } else {
  +    bool is_multi = false;
  +    bool is_ordered = false;
  +    if (!block_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_handle_mgr_.init(false, true, *access_ctx.stmt_allocator_))) {
  +      STORAGE_LOG(WARN, "failed to init block handle mgr", K(ret), K(is_multi), K(is_ordered)); 
  +    } else if (!block_index_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_index_handle_mgr_.init(false, is_ordered, *access_ctx.stmt_allocator_))) {
  +      STORAGE_LOG(WARN, "failed to init block index handle mgr", K(ret), K(is_multi), K(is_ordered));
  +    }
  +    return ret;
  +  }
  +  // never execute
     int64_t range_count = 0;
     bool is_multi = false;
     bool is_ordered = false;
  @@ -1703,9 +1727,9 @@ int ObSSTableRowIterator::init_handle_mgr(
               range_count &gt;= USE_HANDLE_CACHE_RANGE_COUNT_THRESHOLD);
     }
     if (OB_SUCC(ret)) {
  -    if (!block_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_handle_mgr_.init(false, true, *access_ctx.allocator_))) {
  -      STORAGE_LOG(WARN, "failed to init block handle mgr", K(ret), K(is_multi), K(is_ordered));
  -    } else if (!block_index_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_index_handle_mgr_.init(false, is_ordered, *access_ctx.allocator_))) {
  +    if (!block_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_handle_mgr_.init(false, true, *access_ctx.stmt_allocator_))) {
  +      STORAGE_LOG(WARN, "failed to init block handle mgr", K(ret), K(is_multi), K(is_ordered)); 
  +    } else if (!block_index_handle_mgr_.is_inited() &amp;&amp; OB_FAIL(block_index_handle_mgr_.init(false, is_ordered, *access_ctx.stmt_allocator_))) {
         STORAGE_LOG(WARN, "failed to init block index handle mgr", K(ret), K(is_multi), K(is_ordered));
       }
     }
  diff --git a/src/storage/ob_sstable_row_iterator.h b/src/storage/ob_sstable_row_iterator.h
  index ebbbfc17..c6223425 100644
  --- a/src/storage/ob_sstable_row_iterator.h
  +++ b/src/storage/ob_sstable_row_iterator.h
  @@ -426,6 +426,7 @@ private:
     ObSSTableMicroBlockInfoIterator micro_info_iter_;
     int64_t prefetch_handle_depth_;
     int64_t prefetch_micro_depth_;
  +  int hdr_flag_;
   };
     
   }  // namespace storage
    
  diff --git a/src/storage/ob_micro_block_handle_mgr.cpp b/src/storage/ob_micro_block_handle_mgr.cpp
  index 028a2018..bb7f5e00 100644
  --- a/src/storage/ob_micro_block_handle_mgr.cpp
  +++ b/src/storage/ob_micro_block_handle_mgr.cpp
  @@ -45,6 +45,13 @@ void ObMicroBlockDataHandle::reset()
     io_handle_.reset();
   }
     
  +void ObMicroBlockDataHandle::reuse()
  +{
  +  block_index_ = -1;
  +  cache_handle_.reset();
  +  io_handle_.reset();
  +}
  +
   int ObMicroBlockDataHandle::get_block_data(
       ObMacroBlockReader&amp; block_reader, ObStorageFile* storage_file, ObMicroBlockData&amp; block_data)
   {
  @@ -104,7 +111,6 @@ int ObMicroBlockHandleMgr::get_micro_block_handle(const uint64_t table_id,
   {
     int ret = OB_SUCCESS;
     bool found = false;
  -  micro_block_handle.reset();
     if (IS_NOT_INIT) {
       ret = OB_NOT_INIT;
       STORAGE_LOG(WARN, "block handle mgr is not inited", K(ret));
  @@ -128,6 +134,7 @@ int ObMicroBlockHandleMgr::get_micro_block_handle(const uint64_t table_id,
       }
     }
     if (!found) {
  +    micro_block_handle.reuse();
       if (OB_FAIL(ObStorageCacheSuite::get_instance().get_block_cache().get_cache_block(
               table_id, block_ctx.get_macro_block_id(), file_id, offset, size, micro_block_handle.cache_handle_))) {
         if (OB_ENTRY_NOT_EXIST != ret) {
  diff --git a/src/storage/ob_micro_block_handle_mgr.h b/src/storage/ob_micro_block_handle_mgr.h
  index 37f6d005..1ff90688 100644
  --- a/src/storage/ob_micro_block_handle_mgr.h
  +++ b/src/storage/ob_micro_block_handle_mgr.h
  @@ -30,6 +30,7 @@ struct ObMicroBlockDataHandle {
     ObMicroBlockDataHandle();
     virtual ~ObMicroBlockDataHandle();
     void reset();
  +  void reuse();
     int get_block_data(blocksstable::ObMacroBlockReader&amp; block_reader, blocksstable::ObStorageFile* storage_file,
         blocksstable::ObMicroBlockData&amp; block_data);
     TO_STRING_KV(
  diff --git a/src/storage/ob_micro_block_index_handle_mgr.cpp b/src/storage/ob_micro_block_index_handle_mgr.cpp
  index 83beb4e0..4e938a81 100644
  --- a/src/storage/ob_micro_block_index_handle_mgr.cpp
  +++ b/src/storage/ob_micro_block_index_handle_mgr.cpp
  @@ -37,6 +37,13 @@ void ObMicroBlockIndexHandle::reset()
     io_handle_.reset();
   }
     
  +void ObMicroBlockIndexHandle::reuse()
  +{
  +  block_index_mgr_ = NULL;
  +  cache_handle_.reset();
  +  io_handle_.reuse();
  +}
  +
   int ObMicroBlockIndexHandle::search_blocks(const ObStoreRange&amp; range, const bool is_left_border,
       const bool is_right_border, ObIArray&lt;ObMicroBlockInfo&gt;&amp; infos, const ObIArray&lt;ObRowkeyObjComparer*&gt;* cmp_funcs)
   {
  @@ -107,7 +114,6 @@ int ObMicroBlockIndexHandleMgr::get_block_index_handle(const uint64_t table_id,
   {
     int ret = OB_SUCCESS;
     bool found = false;
  -  block_idx_handle.reset();
     if (IS_NOT_INIT) {
       ret = OB_NOT_INIT;
       STORAGE_LOG(WARN, "index handle mgr is not inited", K(ret));
  @@ -127,6 +133,7 @@ int ObMicroBlockIndexHandleMgr::get_block_index_handle(const uint64_t table_id,
       }
     }
     if (!found) {
  +    block_idx_handle.reuse();
       if (OB_FAIL(ObStorageCacheSuite::get_instance().get_micro_index_cache().get_cache_block_index(
               table_id, block_ctx.get_macro_block_id(), file_id, block_idx_handle.cache_handle_))) {
         if (OB_ENTRY_NOT_EXIST != ret) {
  diff --git a/src/storage/ob_micro_block_index_handle_mgr.h b/src/storage/ob_micro_block_index_handle_mgr.h
  index 2aea9dcf..89a19ac0 100644
  --- a/src/storage/ob_micro_block_index_handle_mgr.h
  +++ b/src/storage/ob_micro_block_index_handle_mgr.h
  @@ -23,6 +23,7 @@ struct ObMicroBlockIndexHandle {
     ObMicroBlockIndexHandle();
     virtual ~ObMicroBlockIndexHandle();
     void reset();
  +  void reuse();
     int search_blocks(const common::ObStoreRange&amp; range, const bool is_left_border, const bool is_right_border,
         common::ObIArray&lt;blocksstable::ObMicroBlockInfo&gt;&amp; infos,
         const common::ObIArray&lt;ObRowkeyObjComparer*&gt;* cmp_funcs = nullptr);
</code></pre></div>    </div>
  </li>
  <li>
    <p>减少冗余的代码 &amp; 逻辑优化（部分内容）</p>

    <p>prefetch数据预取逻辑冗余。</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">ObSSTableRowIterator</span><span class="o">::</span><span class="n">inner_open</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ObTableIterParam</span><span class="o">&amp;</span> <span class="n">iter_param</span><span class="p">,</span> <span class="n">ObTableAccessContext</span><span class="o">&amp;</span> <span class="n">access_ctx</span><span class="p">,</span> <span class="n">ObITable</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">query_range</span><span class="p">)</span>
  <span class="p">{</span>
  	<span class="p">...</span>
  	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OB_FAIL</span><span class="p">(</span><span class="n">prefetch</span><span class="p">()))</span> <span class="p">{</span>
  	  <span class="n">STORAGE_LOG</span><span class="p">(</span><span class="n">WARN</span><span class="p">,</span> <span class="s">"Fail to prefetch data, "</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
  	<span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
    
  <span class="kt">int</span> <span class="n">ObMultipleGetMerge</span><span class="o">::</span><span class="n">construct_sstable_iter</span><span class="p">()</span>
  <span class="p">{</span>
  	<span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">OB_SUCC</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prefetch_cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">OB_FAIL</span><span class="p">(</span><span class="n">prefetch</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">STORAGE_LOG</span><span class="p">(</span><span class="n">WARN</span><span class="p">,</span> <span class="s">"fail to prefetch"</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  	<span class="p">...</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>索引回表时去掉多余的reuse。</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="n">ObTableScanStoreRowIterator</span><span class="o">::</span><span class="n">reuse_row_iters</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="p">...</span>
  	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">index_merge_</span><span class="p">)</span> <span class="p">{</span>
  		<span class="n">index_merge_</span><span class="o">-&gt;</span><span class="n">reuse</span><span class="p">();</span> <span class="c1">// 每次 rescan 都会进⾏ reuse</span>
  	<span class="p">}</span>
  	<span class="p">...</span>
  <span class="p">}</span>
    
  <span class="kt">void</span> <span class="n">ObIndexMerge</span><span class="o">::</span><span class="n">reuse</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="c1">// table_iter_.reuse(); </span>
  <span class="n">index_range_array_cursor_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">ObIndexMerge</span><span class="o">::</span><span class="n">get_next_row</span><span class="p">(</span><span class="n">ObStoreRow</span><span class="o">*&amp;</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">......</span>
  <span class="n">table_iter_</span><span class="p">.</span><span class="n">reuse</span><span class="p">();</span> <span class="c1">// 在这⾥ reuse</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OB_FAIL</span><span class="p">(</span><span class="n">table_iter_</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">rowkeys_</span><span class="p">)))</span> <span class="p">{</span>
</code></pre></div>    </div>

    <p>优化refresh table on demand逻辑</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  diff --git a/src/storage/ob_multiple_merge.cpp b/src/storage/ob_multiple_merge.cpp
  index 9aa5cb01..be8de75f 100644
  --- a/src/storage/ob_multiple_merge.cpp
  +++ b/src/storage/ob_multiple_merge.cpp
  @@ -922,7 +922,7 @@ int ObMultipleMerge::prepare_read_tables()
       }
     
       if (OB_SUCC(ret)) {
  -      relocate_cnt_ = access_ctx_-&gt;store_ctx_-&gt;mem_ctx_-&gt;get_relocate_cnt();
  +//      relocate_cnt_ = access_ctx_-&gt;store_ctx_-&gt;mem_ctx_-&gt;get_relocate_cnt();
         if (OB_UNLIKELY(nullptr != row_filter_)) {
           const ObPartitionKey&amp; pkey = partition_store.get_partition_key();
           row_filter_ = tables_handle_.has_split_source_table(pkey) ? row_filter_ : NULL;
  @@ -987,24 +987,20 @@ int ObMultipleMerge::release_table_ref()
   int ObMultipleMerge::check_need_refresh_table(bool &amp;need_refresh)
   {
     int ret = OB_SUCCESS;
  -  if (OB_UNLIKELY(!inited_)) {
  -    ret = OB_NOT_INIT;
  -    STORAGE_LOG(WARN, "ObMultipleMerge has not been inited", K(ret));
  +  if (NULL != access_ctx_-&gt;store_ctx_-&gt;mem_ctx_) {
  +    temp = relocate_cnt_;
  +    relocate_cnt_ = access_ctx_-&gt;store_ctx_-&gt;mem_ctx_-&gt;get_relocate_cnt();
  +    need_refresh = relocate_cnt_ &gt; temp;
     } else {
  -    const bool relocated = NULL == access_ctx_-&gt;store_ctx_-&gt;mem_ctx_
  -                               ? false
  -                               : access_ctx_-&gt;store_ctx_-&gt;mem_ctx_-&gt;get_relocate_cnt() &gt; relocate_cnt_;
  -    const bool memtable_retired = tables_handle_.check_store_expire();
  -    const int64_t relocate_cnt = access_ctx_-&gt;store_ctx_-&gt;mem_ctx_-&gt;get_relocate_cnt();
  -    need_refresh = relocated || memtable_retired;
  +    need_refresh = tables_handle_.check_store_expire();
  +  }
   #ifdef ERRSIM
  -    ret = E(EventTable::EN_FORCE_REFRESH_TABLE) ret;
  -    if (OB_FAIL(ret)) {
  -      ret = OB_SUCCESS;
  -      need_refresh = true;
  -    }
  -#endif
  +  ret = E(EventTable::EN_FORCE_REFRESH_TABLE) ret;
  +  if (OB_FAIL(ret)) {
  +    ret = OB_SUCCESS;
  +    need_refresh = true;
     }
  +#endif
     return ret;
   }
     
  diff --git a/src/storage/ob_multiple_merge.h b/src/storage/ob_multiple_merge.h
  index 12f8cdc2..ed227202 100644
  --- a/src/storage/ob_multiple_merge.h
  +++ b/src/storage/ob_multiple_merge.h
  @@ -164,6 +164,7 @@ class ObMultipleMerge : public ObQueryRowIterator {
     int64_t range_idx_delta_;
     ObGetTableParam get_table_param_;
     int64_t relocate_cnt_;
  +  int64_t temp;
     ObTableStoreStat table_stat_;
     bool skip_refresh_table_;
     bool read_memtable_only_;
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="正确性验证">正确性验证</h2>

<hr>

<p>修改代码的正确性是通过mysqltest运行测试样例来评定，OceanBase代码量庞大，逻辑复杂，自己做的修改难免会出现一些段错误之类的问题，这时候可以开vscode debug，在运行测试用例出错时就会catch住段错误的位置，方便找到问题的根源。</p>

<p>比如这个iter没有初始化的bug就是这样找出来的，改了代码以后会走到ObMultipleMultiScanMerge，mysqltest的测试样例正好测出了这个bug。</p>

<p><img src="/auto-image/picrepo/24980b22-3ff2-4a3a-822e-95d2080a17da.png" alt="Untitled"></p>
  </section>

  
  
  

  <section class="background" data-size="page">
    <!--
  background: ;
  dark: ;
  size: ;
-->


<div class="post-nav">
  <span>
    
      <i class="icon fa-solid fa-angle-left"></i> Previous post<br>
      <a href="/2022/05/25/Oceanbase%E4%B8%ADLSM-Tree%E7%9A%84%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9.html">
        Oceanbase中LSM-Tree的分层设计及其优缺点
      </a>
    
  </span>
  <span>
    
      Next post <i class="icon fa-solid fa-angle-right"></i><br>
      <a href="/2022/08/02/%E9%9D%A2%E5%90%91HTAP%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95.html">
        面向HTAP数据库的基准评测工具研究进展
      </a>
    
  </span>
</div>
  </section>


    </main>
    


<footer class="background" style="--image: url('')" data-dark="true" data-size="wide">
  <!--
    <div>
      Extra details like contact info or address
    </div>
  -->

  <div>
    
      
      
      



  <div class="button-wrapper">
    <a class="button" href="mailto:rzhang@dase.ecnu.edu.cn" data-tooltip="Email" data-style="bare" aria-label="Email">
      <i class="icon fa-solid fa-envelope"></i>
      
    </a>
  </div>


    
      
      
      



  <div class="button-wrapper">
    <a class="button" href="tel:021-62235006" data-tooltip="Phone number" data-style="bare" aria-label="Phone number">
      <i class="icon fa-solid fa-phone"></i>
      
    </a>
  </div>


    
      
      
      



  <div class="button-wrapper">
    <a class="button" href="https://orcid.org/0000-0002-5182-2093" data-tooltip="ORCID" data-style="bare" aria-label="ORCID">
      <i class="icon fa-brands fa-orcid"></i>
      
    </a>
  </div>


    
      
      
      



  <div class="button-wrapper">
    <a class="button" href="https://scholar.google.com/citations?user=iJtZsaQAAAAJ" data-tooltip="Google Scholar" data-style="bare" aria-label="Google Scholar">
      <i class="icon fa-brands fa-google"></i>
      
    </a>
  </div>


    
      
      
      



  <div class="button-wrapper">
    <a class="button" href="https://github.com/dbhammer" data-tooltip="GitHub" data-style="bare" aria-label="GitHub">
      <i class="icon fa-brands fa-github"></i>
      
    </a>
  </div>


    
  </div>

  <div>
    © 2025
    DBHammer
      |   Built with
    <a href="https://github.com/greenelab/lab-website-template">
      Lab Website Template
    </a>
  </div>

  <input type="checkbox" class="dark-toggle" data-tooltip="Dark mode" aria-label="toggle dark mode" oninput="onDarkToggleChange(event)">
</footer>

  </body>
</html>
